# The Clean Coder by Robert C. Martin
## Chapter 1: Professionalism
* Be careful what you ask for
* Non professionals don't have to take responsibility for their job. When a professional makes a mistake, he owns it
* Product is more important than your ego
* Be responsible for your imperfections
* Assume the code is faulty until you check it
* Every time QA finds a problem, be determined to prevent it from happening again
* To know the code works, test it. Then, test it again. And again.
* The code is hard to test if it's been designed to be hard to test
* "If you want your code to be flexible, you have to flex it"
* Merciless refactoring: always make some random acts of kindness to the code whenever you see it
* How do you prove you are not afraid to change the code? You change it all the time.
* It's your responsibility to develop yourself
   * Plan on working 60h/week: 40h for employer, 20h for you. Do the 20h with passion, it should be fun
* Know your domain: discover the abundant wealth of ideas available at the tip of your fingertips. 
* Learn things that are outside of your comfort zone
* The best way to learn is to teach
   * Design patterns
   * Design principles
   * Working Methods: Scrum, Kanban, XP, Structured Analysis, Structured Design
   * Disciplines: TDD, Object Oriented Design, Structured Programming, Continous Integration, Pair Programming
   * Artifacts: 
      * UML
      * DFD
      * Structure Chart
      * Petri Nets
      * Transition Diagrams
      * Flow charts
      * Decision tables
* Identify with your employer - their problems are *your* problems. Understand them and work to develop the solution
* "Programming is an act of supreme arrogance"
## Chapter 2: Saying No
* "Do; or do not. There is no trying." - Yoda
   * When you say you'll try, you're telling you'll use some unused reservoir of energy you've been holding back
* Stop being afraid of confrontation
* Facts > why. 
* The higher the stakes, the more important No becomes
* A team player communicates frequently, keeps an eye for his teammates and does his responsibilities the best he can
* Mind the cost of saying yes. Sometimes the only way to get to the right Yes is to be unafraid to say No
* Don't try to be a hero
## Chapter 3: Saying Yes
* You're not obliged to say Yes to everything, but it's good to work to find ways to make Yes possible
* Use language of Commitment
   * Say what you want. Mean what you say. Do as you mean.
      * Lack of commitment: Need/Should; Hope/wish; Let's
* You can only commit to things you have full control of
* As a professional you're obliged to write code that passes certain standards. Do not cut corners
## Chapter 4: Coding
* Typing blind is about confidence. Being able to sense your errors is really important
* Understand the problem and the way to solve it
* Write the code that solved the problem set by the customer. Make sure the customer defines his problem properly.
* Your code should follow solid engineering principles and be readable by others
* If you don't concentrate doing it, you risk having bugs, wrong structure, opaqueness, convolution and headaches
* If you're tired or distracted, *don't* code
* If you're distracted by some background process in your head, allocate fixed amount of time to it and get back to work
* Avoid the flow zone - you're not hyper productive and certainly not infallible in it
   * It's virtually impossible to enter the flow zone when pair programming
   * You might want to enter it when you're *practicing*
   * Music is the same
* Get enough sleep
* Creative output depends on creative input. Read stuff
* Debugging time is coding time, therefore, do all you can to diminish or avoid it
* Pace yourself. Software development is a marathon, not a sprint
* Creativity and intelligence are fleeting states of mind. Know when to walk away. Learn your patterns of creativity
* Regularely measure your progress and come up with three fact-based dates: best, nominal and worst case
* Hope destroys schedules and ruins reputations
* Overtime might be a good idea if for a short time, you can personally afford it and there's a fallback plan
* Define your "Done" as really completed; do not fall into the trap of false delivery
* Programming is hard. Help others. Accept help gratefully. *Do not protect your turf*. Learn how to ask for help
## Chapter 5: Test Driven Development
* The three laws of TDD
	* You're not allowed to write any production code until you have first written a failing unit test
	* You're not allowed to write more of a unit test than it is sufficient to fail - and noy compiling is failing
	* You're not allowed to write more production code that is sufficient to pass the currently failing unit test
* Benefits
	* Certainty that your code works
	* You lower the defect injection rate
	* You're more confident to *flex* it
	* You document your code by writing unit tests to it
	* It forces you to apply good design patterns
	* The unittests you write after the fact are *defense*. The ones you write before are offense
## Chapter 6: Practicing
### Some Background on Practicing
### The Coding Dojo
### Broadening Your Experience
## Chapter 7: Acceptance Testing
### Communication Requirements
### Acceptance Tests
## Chapter 8: Testing Strategies
### QA Should Find Nothing
### The Test Automation Pyramid
## Chapter 9: Time Managment
### Meetings
### Focus-Manna
### Time Boxing and Tomatoes
### Avoidance
### Blind Alleys
### Marshes, Bogs, Swamps, and Other Messes
## Chapter 10: Estimation
### What Is an Estimate?
### PERT
### Estimating Tasks
### The Law of Large Numbers
## Chapter 11: Pressure
### Avoiding Pressure
### Handling Pressure
## Chapter 12: Collaboration
### Programmers versus People
### Cerebellums
## Chapter 13: Teams and Projects
### Does It Blend?
## Chapter 14: Mentoring, Apprenticeship, and Craftsmanship
### TODO
## Appendix A: Tooling
### TODO

